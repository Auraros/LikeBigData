ZK3 选举机制

```
对与zookeeper提供了三种方式：
1. LeaderElection
2. AuthFastLeaderElection
3. FastLeaderElection (最新默认)
一般来说：zookeeper默认死三个方式。

1. 半数机制： 集群中半数以上机器存活，集群可用。所以Zookeeper适合安装奇数台服务器。
2. Zookeeper 虽然在配置文件中没有指定Master和Slave。但是， Zookeeper 工作时，是有一个节点为Leader，其他则为Follower，Leader是通过内部的选举机制临时产生的。
```



**Zookeeper选举过程中服务器的状态：**

```
LOOKING：寻找leader状态，该状态下，服务器认为当前集群没有leader，会发起leader选举。在选举过程中，所有服务器的状态都是LOOKING。

FOLLOWING：跟随者状态，该状态下，当前服务器是follower，并且知道leader是谁。此时选举已经结束。

LEADING：领导者状态，该状态下，当前服务器是leader，会与follower维持心跳检测。此时选举已经结束。

OBSERVING：观察者状态，该状态下的服务器是observer，不参与选举。
```



**以一个简单的例子来说明整个选举的过程**：
假设有五台服务器组成的Zookeeper集群，他们id从 1-5 ， 同时它们都是最新启动的，也就是没有历史数据，在存放数据量这一点，都是一样的。假设这些服务器依序启动

![image-20201117204903367](C:\Users\Auraros\AppData\Roaming\Typora\typora-user-images\image-20201117204903367.png)

```
(1) 服务器1启动，给自己投票，此时只有它一台服务器启动了，它发出去的报文没有任何响应，所以它的选举状态一直是LOOKING状态。
(2) 服务器2启动，给自己投票，同时与之前启动的服务器1交换结果，由于服务器2的编号大，所以服务器2胜出，但此时投票数没有大于半数，所以两个服务器的状态依然是LOOKING
(3) 服务器3启动，给自己投票,同时与之前启动的服务器1,2交换信息，由于服务器3的编号最大所以服务器3胜出，此时投票数正好大于半数，所以服务器3成为领导者，服务器1,2成为小弟
(4)服务器4启动，给自己投票，同时与之前启动的服务器1,2,3交换信息，尽管服务器4的编号大，但之前服务器3已经胜出，所以服务器4只能成为小弟。
(5)服务器5启动，后面的逻辑同服务器4成为小弟。
```



**选举机制中的概念**

```
1. Serverid: 服务器id；比如有三台服务器，编号分别是1,2,3。(编号越大在选择算法中的权重越大)
2. Zxid：数据id 服务器中存放的最大数据ID.
3. Epoch: 逻辑时钟，或者叫投票的次数，同一轮投票过程中的逻辑时钟值是相同的。每投完一次票这个数据就会增加，然后与接收到的其它服务器返回的投票信息中的数值相比，根据不同的值做出不同的判断。
```



**选举流程图**

![img](https://images2015.cnblogs.com/blog/17071/201702/17071-20170220211539679-433574967.jpg)



**选举状态图**

![img](https://images2015.cnblogs.com/blog/17071/201702/17071-20170220211554960-1891469553.jpg)



**选举详细过程**

一、首先开始选举阶段，每个Server读取自身的zxid。

二、发送投票信息

```
a、首先，每个Server第一轮都会投票给自己。
b、投票信息包含 ：所选举leader的Serverid，Zxid，Epoch。Epoch会随着选举轮数的增加而递增。
```

三、接收投票信息

```
1、如果服务器B接收到服务器A的数据（服务器A处于选举状态(LOOKING 状态)
   1）首先，判断逻辑时钟值：
　　　　a）如果发送过来的逻辑时钟Epoch大于目前的逻辑时钟。首先，更新本逻辑时钟Epoch，同时清空本轮逻辑时钟收集到的来自其他server的选举数据。然后，判断是否需要更新当前自己的选举leader Serverid。判断规则rules judging：保存的zxid最大值和leader Serverid来进行判断的。先看数据zxid,数据zxid大者胜出;其次再判断leader Serverid,leader Serverid大者胜出；然后再将自身最新的选举结果(也就是上面提到的三种数据（leader Serverid，Zxid，Epoch）广播给其他server)
　　　　b）如果发送过来的逻辑时钟Epoch小于目前的逻辑时钟。说明对方server在一个相对较早的Epoch中，这里只需要将本机的三种数据（leader Serverid，Zxid，Epoch）发送过去就行。
　　　　c）如果发送过来的逻辑时钟Epoch等于目前的逻辑时钟。再根据上述判断规则rules judging来选举leader ，然后再将自身最新的选举结果(也就是上面提到的三种数据（leader  Serverid，Zxid，Epoch）广播给其他server)。

  2）其次，判断服务器是不是已经收集到了所有服务器的选举状态：若是，根据选举结果设置自己的角色(FOLLOWING还是LEADER)，退出选举过程就是了。
最后，若没有收到没有收集到所有服务器的选举状态：也可以判断一下根据以上过程之后最新的选举leader是不是得到了超过半数以上服务器的支持,如果是,那么尝试在200ms内接收一下数据,如果没有新的数据到来,说明大家都已经默认了这个结果,同样也设置角色退出选举过程。

 2、 如果所接收服务器A处在其它状态（FOLLOWING或者LEADING）。

　　　　a)逻辑时钟Epoch等于目前的逻辑时钟，将该数据保存到recvset。此时Server已经处于LEADING状态，说明此时这个server已经投票选出结果。若此时这个接收服务器宣称自己是leader, 那么将判断是不是有半数以上的服务器选举它，如果是则设置选举状态退出选举过程。
　　　　b) 否则这是一条与当前逻辑时钟不符合的消息，那么说明在另一个选举过程中已经有了选举结果，于是将该选举结果加入到outofelection集合中，再根据outofelection来判断是否可以结束选举,如果可以也是保存逻辑时钟，设置选举状态，退出选举过程。
```

